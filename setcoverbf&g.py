# -*- coding: utf-8 -*-
"""SetCoverBF&G.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xs5yN8PCx5p-_v0onPKuxlYcx8sDoi5O
"""

# Commented out IPython magic to ensure Python compatibility.
#Untuk melihat secara detail waktu eksekusi program


# %load_ext autotime

from itertools import permutations

#Pencarian solusi melalui brute force
def setCovBF(x, h):
    comb = []
    for n in range(len(h)) :
        #Membangun array comb(kombinasi)
        comb.append(n)
    kSol = []
    kemungkinan = []
    for i in range(len(comb)) :
        #Pencobaan seluruh kemungkinan gabungan set
        comb[i] = permutations(h, i+1)
        for j in comb[i] :
            Solution = set()
            kSol = j
            kemungkinan.append(kSol)
            sol = []
            print("Hasil percobaan gabungan himpunan : ", j)
            for k in range(len(j)) :
                #Mengubah dari bentuk tuple menjadi bentuk set untuk menemukan solusinya
                Solution.update(Solution.union(j[k]))
                for l in range(len(h)) :
                    if (j[k] == h[l]) :
                        #Mengubah dari bentuk nilai solusi menjadi bentuk gabungan himpunan solusi
                        sol.append("h["+str(l)+"]")
            if (Solution == x) :
                print("Solusi ditemukan")
                return sol

#Pencarian solusi melalui greedy
def setCovG(x, h):
    y = set()
    sol = []
    max = set()
    max = h[0]
    y.update(y.union(max))
    sol.append("h[0]")
    j = 0
    while (len(y) != len(x)):
            #Mencari gabungan himpunan yang memiliki perbedaan isi yang paling banyak
        if (len(max) < len(y.union(h[j]))) :
            max = set()
            max.update(y.union(h[j]))
            tmp = j
        if (len(max) == len(x)) or (j+1 == len(h)) :
            #Memasukkan himpunan tersebut ke dalam array solusi
            sol.append("h["+str(tmp)+"]")
            y.update(y.union(max))
            if (len(y) == len(x)) :
                print("Solusi ditemukan")
            if (j+1 == len(h)) :
                j = 0
                print("Hasil percobaan sementara : ",sol)
        j=j+1
    return sol

#Main

#Percobaan worst case(solusi sepanjang n)
h = []
for i in range(5) :
    #Membuat array h
    h.append(i)
    h[i] = set()
for i in range(5) :
    #Memasukin nilai pada setiap iterasi array h
    j = i*2
    h[i].add(j)
    h[i].add(j+1)
#Solusi yang perlu dicari
all = set()

for i in range(len(h)):
    all.update(all.union(h[i]))
print("Solusi yang ingin dicari = ",all)

#Percobaan average case(solusi berada di tengah n / tidak mengambil seluruh himpunan sebagai solusi)
h = [0,1,2,3,4]
h[0] = {1,2,3,4}
h[1] = {2,3,4,5}
h[2] = {5,6,7,8}
h[3] = {6,7,8,9}
h[4] = {9,10,11,12}

#Solusi yang perlu dicari
all = set()

for i in range(len(h)):
    all.update(all.union(h[i]))
print("Solusi yang ingin dicari = ",all)

#Hasil solusi dengan menggunakan strategi Brute Force
solBF = setCovBF(all, h)
print("Hasil solusi dengan strategi Brute Force = ",solBF)

#Hasil solusi dengan menggunakan strategi Greedy
solG = setCovG(all, h)
print("Hasil solusi dengan strategi Greedy = ",solG)